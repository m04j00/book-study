# 07. 오류 처리


> 오류 처리는 중요하다. 하지만 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다.

<br>

### 오류 코드보다 예외를 사용하라

코드 논리와 오류 처리 코드가 뒤섞이지 않게 하기 위해 오류 발생 시 예외를 던지는 것이 바람직하다.

```java
// 논리와 오류 처리가 뒤섞이는 경우
public void sendShutDown(){ 
	DeviceHandle handle = getHandle(DEV1);
	if(handle != ...) {
		if(handle.status == ...) {
		}
	}
}
```

```java
// 예외를 던져 논리와 오류처리가 뒤섞이지 않는 경우
public void sendShutDown(){ 
	try {
		tryToShutDown();
	} catch (DeviceShutDownError e) {
		...
	}
}
```

<br>

### Try - Catch - Finally 문부터 작성하라

> `try` 블록에서 무슨 일이 생기든지 `catch` 블록은 프로그램 상태를 일관성 있게 유지해야 한다.
> 

`try - catch - finally`문으로 시작하는 경우 `try` 블록 내부의 상황과는 관계없이 호출자가 기대하는 상태를 정의하기 쉬워진다.

> 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다. 그러면 자연스럽게 `try` 블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다.
> 

<br>

### 미확인 예외를 사용하라

```java
이떄, 확인/미확인 예외란?
확인된 예외 : 컴파일러가 검사하는 예외 (IOException, ClassNotFound ...)
컴파일러는 프로그램이 **확인된 예외**를 처리할 수 있는지 확인하고, 처리할 수 없다면 **컴파일 오류**를 발생시킨다.

미확인 예외 : 컴파일러가 검사하지 않는 예외 (RuntimeException, Error 와 자식 클래스)
예외가 코드에 의해 처리되지 않았더라도 컴파일러는 프로그램을 성공적으로 컴파일한다. 다만 예외가 처리될 때까지 **프로그램 실행이 불가능**하다.
```

자바의 첫 버전이 확인된 예외를 지원했을 때에는 멋진 아이디어로서 여겨졌으나 지금은 확인된 예외를 지원하지 않더라도 안정적인 소프트웨어 구현에 아무 문제가 없다. 

> 그러므로 우리는 확인된 오류가 치르는 비용에 상응하는 이익을 제공하는지 (철저히) 따져봐야 한다. (생략) 확인된 예외는 OCP(Open Closed Principle)를 위반한다.
> 

* OCP : 애자일 원칙 중 하나로, 새로운 기능을 추가하기 위해 기존 코드를 변경해야 한다면 이는 좋지 않은 설계라는 이론이다.

> 즉, 하위 단계에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 한다는 말이다.
> 

라이브러리 작성 등 확인된 예외가 유용한 상황도 물론 존재하지만, 일반적으로는 의존성이라는 비용이 이익보다 크다.

<br>

### 예외에 의미를 제공하라

> 예외를 던질 때는 전후 상황을 충분히 덧붙인다. 그러면 오류가 발생한 원인과 위치를 찾기가 쉬워진다. (생략) 오류 메시지에 정보를 담아 예외와 함께 던진다.
> 
- 실패한 연산 이름, 실패 유형 등의 정보를 담아 충분한 정보를 넘겨준다.

<br>

### 호출자를 고려해 예외 클래스를 정의하라

오류는 디바이스 실패, 네트워크 실패, 프로그래밍 오류 등 다양한 방법으로 분류한다. 그러나 **오류를 정의하는 방법**은 곧 **오류를 잡아내는 방법**이 되어야 한다.

`오류를 처리하는 방식` : 오류 기록 → 프로그램을 계속 수행해도 좋은지 확인

> 위 경우는 예외에 대응하는 방식이 예외 유형과 무관하게 거의 동일하다. 그래서 코드를 간결하게 고치기가 아주 쉽다. 호출하는 라이브러리 API를 감싸면서 예외 유형 하나를 반환하면 된다.

<br>

**외부 API 사용시 감싸기 기법이 가져다주는 효과**

- 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어듦
- 라이브러리 변경 시 적은 비용 발생
- (외부 API호출 대신 테스트 코드를 넣어줌) 프로그램 테스트가 용이
- 프로그램이 사용하기 편리한 API 정의 가능 (설계방식에 얽매이지 않음)

<br>

### 정상 흐름을 정의하라

> 앞 절에서 충고한 지침을 충실히 따른다면 (생략) 코드 대부분이 깨끗하고 간결한 알고리즘으로 보이기 시작한다. 하지만 그러다보면 오류 감지가 프로그램 언저리로 밀려난다. (생략) 대개는 멋진 처리 방식이지만, 때로는 중단이 적합하지 않은 때도 있다.
> 

클라이언트 코드가 예외적인 상황을 처리할 필요가 없도록 클래스나 객체를 조작하여 그 클래스/객체가 예외적인 상황을 캡슐화해서 특수 사례를 처리하는 방식이 존재한다. 이를 **[특수 사례 패턴](https://velog.io/@yeahg_dev/Special-Case-Pattern)**이라 부른다. 

<br>

### null을 반환하지 마라

null을 반환하는 습관은 우리가 흔히 저지르는 오류 유발 행위이다. 

> null을 반환하는 코드는 일거리(null을 확인하는 코드)를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다. 누구 하나라도 null 확인을 빼먹는다면 애플리케이션이 통제 불능에 빠질지도 모른다.
> 

`나쁘다!`

> 메서드에서 null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환한다.
> 

대부분 특수 사례 객체가 손쉬운 해결책이다.

<br>

### null을 전달하지 마라

> 대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다. (생략) 즉, 인수로 null이 넘어오면 코드에 문제가 있다는 말이다.
> 

<br>

### 느낀점

이번 챕터는 `null`에 관한 내용이 많이 와닿았던 것 같다. Java를 주로 사용해왔던 내가 Kotlin을 사용하면서 `nullable/Non-Nullable` 개념을 처음 접해보았고, 프로젝트 코드에 `if(A ≠ null)`을 엄청나게 넣을 수 밖에 없었다. 그러다보니 저자가 언급했던 것처럼 실수로 null 확인을 빼먹어 오류로 이어진 경험도 많고, 인수로 null을 넣은 경험도 많다. 특수 사례 객체 말고도 코틀린이 Null Safety개념을 만들면서 제안한 올바른 null 처리법이 따로 있을 수도 있지만, 생각없이 null을반환하고, 전달했던 습관들은 고쳐야 할 것 같다.
