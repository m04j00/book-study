# 8장 경계

> 어떤 식으로든 이 외부 코드를 우리 코드에 깔끔하게 통합해야만 한다.
이 장에서는 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교를 살펴본다.
> 

    처음 이 **경계**라는 단어를 보았을때에는 아래 의미를 나타내는 경계일것이라고 생각했다.
    
    경계(警戒)
    잘못되는 일이 일어나지 않도록 미리 조심하는 것.
    
    하지만 이 책에서 말하는 경계는 사전적 의미로 아래와 같다. 
    
    경계(境界)
    일정한 기준에 따라 분간이 되는 사물의 한계

  즉, 미리 조심하다는 의미에서의 경계가 아닌, A와 B사이의 분리되는 지점 그 경계를 일컫는다는 것은 인지하기 바란다.

<br>

## 외부 코드 사용하기

**제공자와 사용자 사이의 외부코드에 대한 동상이몽 비교**

|  | 코드 제공자 | 코드 사용자 |
| --- | --- | --- |
| 희망하는 코드 | 적용성이 넓은 코드 | 자신의 요구에 집중하는 코드 |
| 이유 | 더 많은 환경에서 돌아가야 더 많은 고객이 구매하기 때문 | 제공된 코드가 자신의 요구에 집중되면 더 높은 효율을 낼 수 있기 때문 |

위와 같은 제공자와 사용자 사이의 팽팽한 긴장으로 인해 시스템 경계에서 문제가 발생한 소지가 높다고 말한다.

이 책에서는 Map을 예시로 들며, 프레임워크에서 제공되는 Map이 적용성이 넓은(기능성과 유연상이 높다) 반면 얼마나 위험한지도 함께 알려주고 있다. 

- 누구든지 clear()메소드를 이용해 Map의 내용을 삭제할 수 있다
- 사용자에게 필요하지 않은 기능까지 제공한다.
- 제네릭을 통해 특정 객체만을 받겠다는 선언을 하지 않는 이상 다양한 Object 객체가 Map에 포함될 수 있다.
- 심지어 제네릭을 사용하면 인터페이스가 변경될 경우 일찍히 다양하게 분포되어 있는 Map과 관련된 모든 코드를 수정해야한다.
    - `Map<String, User>` → `Map<String, UserInfo>`로 변경된 경우 이와 관련된 **모든** 코드를 User→ UserInfo로 수정해주어야한다.
    - 그래서 실제로 제네릭스 사용을 금지한 시스템도 있었다.
    

이를 해결하기 위해 경계 인터페이스인 Map을 사용할 객체안으로 숨겨 인터페이스가 변하더라도 나머지 프로그램에는 영향을 미치지 않게 할 수 있다.

<br>

> Map 클래스를 사용할 때마다 위와 같이 캡슐화 하라는 소리가 아니다. 
Map과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다.
> 

<br>

## 경계 살피고 익히기

> 외부 코드를 익히기는 어렵다. 
외부 코드를 통합하기도 어렵다. 
두 가지를 동시에 하기는 두 배나 어렵다.
> 

> 다르게 접근하면 어떨까? 
곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까? 
짐 뉴커크는 이를 **학습 테스트**라 부른다.
> 

> **학습 테스트**는 프로그램에서 사용하려는 방식대로 외부 API를 호출한다.
통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다.
학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다.
> 

<br>

## log4j 익히기

    내 개인적으로는 왜 이 타이밍에 log4j를 익히는 방법이 나오는지 흐름상 잘 이해하지 못하였다. 만약, 이와 관련하여 의견이 있다면 알려주기 바란다!
    → 이해했다! 바로 이 주제에서는 저자가 직접 학습 테스트를 통해 log4j를 익혀나간 방식을 보여주고 있다. 저자와 함께 학습 테스트를 진행해 볼 수 있는 것이다.


이 주제에서는 저자가 학습테스트를 통해 log4j를 익혀나간 과정에 대해 작성하고 있다. 

일단 우리의 프로그램에서 사용하려는 방식 그대로 외부 API를 호출한다. 외부코드에 우리의 코드를 맞추는 것이 아닌, 우리 코드에 외부 코드를 맞추어 나가며 통제권을 잃지 않고, log4j를 익혀나갈 수 있다!

또한 이러한 학습을 통해 다양한 부분을 맞춰가며 테스트를 하기 때문에 돌아가는 방식 또한 자연스레 익혀나가게 되며, 얻은 지식을 간단한 단위 테스트 몇개로 표현할 수 있게 된다.

<br>

## 학습 테스트는 공짜 이상이다

- 학습테스트에 드는 비용은 없다.
    - 오히려 필요한 지식만 확보하는 손쉬운 방법이다.
    - 이해도를 높여주는 정확한 실험이다.
- 학습테스트는 공짜 이상이다.
    - 투자하는 노력보다 얻는 성과가 더 크다.
- 학습 테스트는 패키지가 에상대로 도는지 검증한다.
    - 패키지는 새 버전이 나올 때마다 새로운 위험이 생기지만, 만약, 새 버전이 코드와 호환되지 않으면 학습테스트가 이를 바로 밝혀낸다.

> 이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다.
> 

<br>

## 아직 존재하지 않는 코드를 사용하기

> 경계와 관련해 또 다른 유형은 **아는 코드와 모르는 코드를 분리**하는 경계다.
> 

> 때로는 우리 지식이 경계 너머에 미치지 못하는 코드 영역도 있다. 때로는 (적어도 지금은) 알려고 해도 알 수가 없다. 때로는 더 이상 내다보지 않기로 결정한다.
> 

이 주제에서 책은 지식 너머에 있는 소프트웨어 개발을 할때, 해당 인터페이스 구현을 나중으로 미루고, 자체적으로 인터페이스를 정의해 간단한 클래스와 메서드를 추가하여, **오히려 개발자 자신이 바라는 인터페이스로 구현**하는 경험담을 이야기 한다. 

즉, 이전의 우리가 통제하지 못하고 정의되지도 않은 API를 억지로 사용하는 것이 아닌, 우리에게 필요한 인터페이스로 직접 정의하여 이후 실제 구현해야할 인터페이스와의 간극은 ADAPTER 패턴을 이용해 캡슐화 함으로써 좁혀나가는 모습을 보여준다.

<br>

## 깨끗한 경계

> 경계에서는 흥미로운 일이 많이 벌어진다. 변경이 대표적인 예다.
> 

> 통제하지 못하는 코드를 사용할 때는 너무 많은 투자를 하거나 향후 변경 비용이 지나치게 커지지 않도록 **각별히** 주의해야 한다.
> 

> 경게에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다.
> 

> 이쪽 코드에서 외부 패키지를 세세하게 알아야 할 필요가 없다. 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다. 자칫하면 오히려 외부 코드에 휘둘리고 만다.
> 

> 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.
Map에서 봤듯이, 새로운 클래스로 경계를 감싸거나 아니면 ADAPTER 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자.
> 

    ADAPTER 패턴
      - 디자인 패턴의 일종으로 한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다.
      - 어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.
      - 한국 플러그를 일본 콘센트에 꽂기 위해 변압기를 사용하듯이 A인터페이스 구현한 클래스에서 B인터페이스를 사용하고자 할때, A와 B인터페이스를 연결하기 위한 중간 다리 역할을 하는 디자인 패턴을 말한다.

<br>

## 느낀점

**경계**에 대해서 알아보는 주제였다. 

처음에는 앞서 말했듯 외부 코드를 경계하라는 의미에서의 경계인줄만 알았다. 이전까지도 예외처리를 통해 많은것을 경계했어야 했기에.. 하지만 이번 주제에서의 경계는 외부 코드와 (우리) 코드 사이의 지점 그 경계에 대해 이야기 하고 있다. 

이 주제에서 말하듯 내 코드는 그 자체로써 주체가 되지 못하고, 외부의 다양한 오픈소스 혹은 프레임워크에서 제공하는 코드에 맞춰져 작성해 왔던것 같다. 프레임워크에서 타입을 변경하라고 하면, 해당 소스를 사용하기 위해 내 코드를 여김없이 변경해왔다. 하지만 한번도 이에 대해 이상함을 느끼지 않고, 오히려 변경했음에도 코드가 잘 수행되지 않는다면 프레임워크가 원하는 방향에 맞추지 못한 내 코드에 문제가 있다고 생각하기만 했다.

그렇기에 이번 주제는 꽤나 충격으로 다가왔다.(솔직히 매 챕터가 나에겐 충격 그자체이긴 하다…) 외부 코드를 제공하는 제공자들은 당연하게도 자신들의 코드가 A에서도, B에서도 잘 돌아가길 바란다. 하지만 나는 내 코드 그 자체에서만 잘 돌아가면 되는 이 간극에 대해 한번도 생각해본적이 없었기 때문이다. 

나는 이 책을 보고 오히려 많은 개발자들이 이 간극에 대해 생각해보고, 내주기만 하는 코드가 아니라 외부 코드가 자신의 코드에 자연스레 스며드는 코드를 개발하기 위해 한번쯤은 노력해보는 시간이 되었으면 한다. 물론 너무 ‘너 외부코드! 내 코드에 맞춰!’가 되어서 코드가 돌아가지 않으면 안되지만, 한번쯤은 생각해보자~ 하는 것이다.

생각보다 많은 곳에서 외부코드와의 경계에 부딪힌다. 아니 어쩌면 대부분의 코드가 외부코드와 맞닿아 있을 수도 있다. 이처럼 이제는 코드를 볼때 외부 코드와 내 코드를 구분 할 수 있게된것 같다. 너무나도 자연스럽게 내 코드처럼 사용하던 외부코드들에 대해 인지하게 되는 시간이었고, 이와 더불어 ADAPTER 패턴까지 알아볼 수 있는 주제였다.
