# 8. 경계

> 이 장에서는 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교를 살펴본다.
> 

### 외부 코드 사용하기

- Map은 다양한 인터페이스로 수많은 기능을 제공한다. 프로그램에서Map을 만들어 여기저기 넘긴다면 누구나 특정 객체를 삭제하고 유형을 추가할 수 있다.

```java
// 1. Sensor 객체를 담는 Map
Map sensors = new HashMap();

Sensor s = (Sensor)sensors.get(sensorId);
```

- 위 코드는 Map이 반환하는 오브젝트를 올바른 유형으로 변환할 책임은 Map을 사용하는 클라이언트에게 있다.
- 코드는 동작하지만 깨끗한 코드라 보기 어렵고 의도도 분명히 드러나지 않는다.

```java
// 2. 제네릭스 사용
Map<String, Sensor> sensors = new HashMap<Sensor>();

Sensor s = sensors.get(sensorId);
```

- 제네릭스를 사용하면 코드 가독성이 크게 높아진다.
- 그렇지만 `Map<String, Sensor>`가 사용자에게 필요하지 않는 기능까지 제공하는 문제는 해결하지 못한다.
- `Map<>` 인스턴스를 여기저기 넘기면 Map 인터페이스가 변할 경우 수정할 코드가 상당히 많아진다.

```java
// 3. Sensors 내부에 Map 사용 
public class Sensors {
	private Map sensors = new HashMap();

	public Sensor getById(String id) {
		return (Sensor) sensors.get(id);
}
```

- 경계 인터페이스인 Map을 Sensors 안으로 숨긴다.
- Map 인터페이스가 변해도 다른 프로그램에는 영향을 미치지 않는다. 제네릭스의 사용 여부도 문제가 되지 않는다.
- Sensors 클래스는 프로그램에 필요한 인터페이스만 제공해 코드 이해가 쉽고 오용을 방지할 수 있다.

- Map 클래스를 사용할 때마다 캡슐화를 권장한다. 즉 경계 인터페이스를 여기저기 넘기지 말아야 한다.
- 경계 인터페이스를 사용할 때 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다.

### 경계 살피고 익히기

**학습 테스트**

- 프로그램에서 사용하려는 방식대로 외부 API를 호출한다.
- 통제된 환경에서 API를 이해하고 사용하려는 목적에 초점을 맞춘다.

### 아직 존재하지 않는 코드 사용하기

> 경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다.
> 
- 우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점 및 코드 가독성도 높아지고 코드 의도도 분명해진다.
- 엉클 밥은 정의되지도 않은 API에서 Controller를 분리했다. 우리에게 필요한 인터페이스를 정의했으므로 Controller 코드는 깔끔하고 깨끗했다. 
API를 정의한 후 Adapter를 구현해 간극을 메꾸고 ADAPTER 패턴으로 API 사용을 캡슐화해 API가 바뀔 때 수정할 코드를 한 곳으로 모았다.

### 깨끗한 경계

- 경계에 위치하는 코드는 깔끔히 분리한다.
- 기대치를 정의하는 테스트 케이스를 작성한다.
- 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 좋다.
- 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리해야 한다.
    - 새로운 클래스로 경계를 감싸거나 ADAPTER 패턴을 사용해 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환한다.
    - 코드 가독성이 높아지며 경계 인터페이스를 사용하는 일관성도 높아지며 외부 패키지가 변했을 때 변경할 코드의 양도 줄어든다.
