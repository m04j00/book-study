# 08. 경계

> 시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드물다. (생략) 어떤 식으로든 이 외부 코드를 우리 코드에 깔끔하게 통합해야만 한다.
> 

<br/>

### 외부 코드 사용하기

더 많은 고객에게 서비스를 제공하기를 원하는 인터페이스 제공자와 자신의 요구에 집중하는인터페이스를 바라는 사용자 사이에서 발생하는 긴장으로 시스템 경계에서 문제가 생길 소지가 많다.

```java
Map sensors = new HashMap();    // 1
Map<String, Sensor> sensors = new HashMap<Sensor>();  // 2
public class Sensors {   // 3
	private Map sensors = new HashMap();
	...
}
```

위 코드에서 1,2,3번은 공통적으로 Map을 만들고 있다. 
1번 코드의 경우 누구나 sensors를 변경 및 삭제할 권한이 있고, 객체 유형을 제한하지 않고 있다.
이 때 코드는 동작하지만 깨끗한 코드라고 보긴 어렵다. 제네릭스를 사용한 2번 코드의 경우 가독성이 크게 높아졌으나, 마찬가지로 사용자에게 필요하지 않은 기능까지 제공한다. 

1,2번 코드의 문제점을 보완한 3번 코드를 보면 경계 인터페이스인 Map을 Sensors(class) 안으로 숨겨 프로그램이 필요로 하는 인터페이스만 제공하고, 인터페이스가 변경되더라도 문제될 것이 없다.

> Map 클래스를 사용할 때마다 위와 같이 캡슐화하라는 소리가 아니다. Map(혹은 유사한 경계 인터페이스를) 여기저기 넘기지 말라는 말이다.


<br/>

### 경계 살피고 익히기

> 외부 코드를 익히기는 어렵다. (생략) 곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까? 짐 뉴커크는 이를 학습 테스트라 부른다.

학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API를 호출한다.
> 

<br/>

### log4j 익히기

아파치의 log4j를 사용하여 로깅 기능을 직접 구현하지 않고 콘솔 로거를 초기화하는 방법을 예시로 들었다.

<br/>

### 학습 테스트는 공짜 이상이다

학습 테스트 : 기능 구현보다는 API, 라이브러리, 프레임워크의 동작을 검증하는 테스트

> 학습 테스트에 드는 비용은 없다. (생략) 투자하는 노력보다 얻는 성과가 더 크다. (생략)
이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다. 그렇지 않다면 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠지기 쉽다.
> 

<br/>

### 아직 존재하지 않는 코드를 사용하기

경계의 또다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다. 
저자는 API가 설계되지 않은 상태에서 코드를 진행하기 위해 자체적인 인터페이스를 정의한 과정을 설명한다. 이떄 정의된 인터페이스와 이후 실제로 구현해야 할 인터페이스간의 간극을 ADAPTER패턴으로 좁혀나간다고 언급하였다.

<br/>

### 깨끗한 경계

소프트웨어 설계가 우수하다면 경계에서 변경이 일어난다고 해도 많은 비용이 들지 않는다. 

> 경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트케이스도 작성한다. (생략) 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.
> 
- 위에서 언급된 Map의 예시처럼 새로운 클래스로 경계를 감싸기
- ADAPTER 패턴을 사용하여 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하기

를 사용한다면 코드 가독성, 일관성이 높아질 뿐만 아니라 외부패키지 변경시 드는 비용이 줄어든다.
