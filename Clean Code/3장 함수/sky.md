# 03. 함수
<br/>

### 작게 만들어라

> 지금까지 경험을 바탕으로 그리고 오랜 시행착오를 바탕으로 나는 작은 함수가 좋다고 확신한다. (생략) 이 말은 중첩 구조가 생길만큼 함수가 커져서는 안 된다는 뜻이다. 그러므로 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다. 당연한 말이지만, 그래야 함수는 읽고 이해하기 쉬워진다.
> 

<br/>

### 한 가지만 해라!

함수가 ‘한 가지’만 하는지 판단하는 방법

- 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행하는지 확인한다.
- 단순히 다른 표현이 아닌 의미 있는 이름으로 다른 함수를 추출할 수 있는지 확인한다.

> 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어려운 탓이다.

**내려가기 규칙 ;** 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한번에 한 단계씩 낮아지는 것
>

<br/>

### 서술적인 이름을 사용하라!

> 좋은 이름이 주는 가치는 아무리 강조해도 지나치지 않다. (생략) 한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 이런 원칙을 달성함에 있어 이미 절반은 성공했다.
> 

우리는 변수, 함수, 클래스의 이름이 길어질수록 무서워한다. 하지만 필자는 길고 서술적인 이름이 짧고 어려운 이름 / 길고 서술적인 주석보다 좋다고 언급하였다. 

> 이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.
> 

예시 → `includeSetupAndTeardownPages`, `incloudSetupPages`

<br/>

### 함수 인수

> 함수에서 이상적인 인수 개수는 0개(무항)다. 다음은 1개(단항)고, 다음은 2개(이항)다. 3개(삼항)은 가능한 피하는 편이 좋다.
> 

**많이 쓰는 단항 형식**

- 인수에 질문을 던지는 경우 : boolean fileExists(”MyFile”)
- 인수를 뭔가로 변환해 결과를 반환하는 경우
- 이벤트 ; 함수 호출을 이벤트로 해석해 입력 인수로 시스템 상태를 바꾸는 경우

**플래그 인수**

> 플래그 인수는 추하다. 함수로 부울 값을 넘기는 관례는 정말로 끔찍하다.
> 

`render(boolean isSuite)`보다는 `renderForSuite(), renderForSingleTest()`로 구분지어 사용하자.

**이항 함수**

> 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
> 

인수가 2개인 함수와 1개인 함수를 비교했을 때, 두 함수 모두 의미가 명백할 수는 있어도 일부 함수의 경우 인수가 2개일 때 첫번째 인수를 무시해야 하는 경우가 생긴다. (outputStream을 그 예로 들 수 있다.) 그러나 어떤 코드든 무시한다면 그 코드에 오류가 숨어든다.

**삼항 함수**

> 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다.
> 

순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어나므로 삼항 함수를 만들 때에는 신중히 고려해야 한다.

**인수 객체**

> 인수가 2-3개 필요하다면 일부를 독자적인 클래스로 선언할 가능성을 짚어 본다.
> 

그 예시로 `x,y,radius`라는 3개의 인수를 Point객체를 사용하여 `point, radius`로 표현할 수 있다.

**인수 목록**

> 때로는 인수 개수가 가변적인 함수도 필요하다.
> 

`String.format` 메서드처럼 가변 인수 전부를 동등하게 취급하면 List형 인수 하나로 취급할 수 있게 된다.

**동사와 키워드**

> 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
> 

함수 이름에 키워드(인수 이름)를 추가함으로써 인수 순서를 기억할 필요가 없도록 구성할 수 있다. → `assertExpectedEqualsActual(expected, actual)`
