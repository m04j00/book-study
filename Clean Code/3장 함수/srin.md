# 3장 함수

<br>

## 작게 만들어라!

> 함수를 만드는 첫째 규칙은 ‘작게!’다. 함수를 만드는 둘째 규칙은 ‘더 작게!’다.
> 

> *블록과 들여쓰기*
if문, else문, while문 등에 들어가는 블록은 한 줄이어야 한다는 의미다.
그러면 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다.
> 

<br>

## 한 가지만 해라!

> **함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.**
> 

Q. 여기서 한 가지란 무엇일까?

> 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다. 
…
단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.
> 

여기서 말하듯 그저 표현만이 다르다면 그건 이미 한 가지 일을 하고 있는 것일 수 있다.

함수명 includeId와 existId가 하는 역할이 다르지 않은것 처럼 말이다. 

> 한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.
> 

<br>

## 함수 당 추상화 수준은 하나로!

앞서 나왔던 내용과 중복되는 내용이다. 그만큼 중요하다는 뜻이겠지?

> 함수가 확실히 ‘한 가지’ 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
> 

> *위에서 아래로 코드 읽기 : **내려가기** 규칙*
…
위에서 아래로 TO 문단을 읽어내려 가듯이 코드를 구현하면 추상화 수준을 일관되게 유지하기가 쉬워진다.
> 

<br>

## Switch문

> Switch 문을 작게 만들기 어렵다.
> 

> 본질적으로 switch문은 N가지를 처리한다. 불행하게도 switch 문을 완전히 피할 방법은 없다.
> 

해당 책에서는 이를 추상 팩토리(abstract factory)에 숨겨 해결하고자 한다. 

즉, 추상클래스를 구현하는 클래스를 분기로 처리할때 추상메서드로 switch문을 작성하여 해당 switch문이 여러 상황을 처리하지 않을 최소의 상황을 만들며, 상속 관계로 숨겨 절대 다른 코드에 노출하지 않도록 한다고 한다. 하지만 필자도 해당 규칙을 위반한 경험이 많다고 서술한다^^


<br>

## 서술적인 이름을 사용하라!

> 좋은 이름이 주는 가치는 아무리 강조해도 지나치지 않다.
> 

> 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.
> 

> 이름이 길어도 괜찮다. 겁먹을 필요없다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
> 

> 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.
> 

> 이름을 붙일 때는 일관성이 있어야 한다.
> 

즉, 앞서 보였던 예제를 들어 부가 설명 하자면, 어떤것은 includeId, 또 다른것은 existPassword일 경우 같은 역할을 함에도 다른 단어가 사용됨으로써 다음 독자로 하여금 혼란을 줄 수 있다. 

서술적인 이름을 통해 해당 코드를 **짐작**할 수 있다면 그건 좋은 코드에 한발자국 더 다가서게 된 것이라 말할 수 있겠다!

<br>

## 함수 인수

> 함수에서 이상적인 인수 개수는 0개(무항)다. 다음은 1개(단항)고, 다음은 2개(이항)다. 3개(삼항)은 가능한 피하는 편이 좋다.
> 

> 인수는 어렵다. 인수는 개념을 이해하기 어렵게 만든다.
> 

> 테스트 관점에서 보면 인수는 더 어렵다.
> 

*많이 쓰는 단항 형식*

1. 인수에 질문을 던지는 경우
2. 인수를 뭔가로 변환해 결과를 반환하는 경우
3. 이벤트 함수에서 입력(Scan) 인수로 시스템 상태를 바꾸는 경우
(단, 이벤트라는 사실이 코드에 드러나야함)

<br>

*플래그 인수(Flag)*

> 함수로 bool 값을 넘기는 관례는 정말로 끔찍하다.
> 

<br>

*이항 함수*

> 이항 함수가 무조건 나쁘다는 소리는 아니다. 프로그램을 짜다보면 불가피한 경우도 생긴다. 하지만 그만큼 위험이 따른다는 사실을 이해하고 가능하면 단항 함수로 바꾸도록 애써야 한다.
> 

<br>

*삼항 함수*

> 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다. 
…
그래서 삼항 함수를 만들 때는 신중히 고려하라 권고한다.
> 

왜? 잘 생각해보자, 매번 함수를 볼때마다 주춤(?)하게 되는 코드일 수 있다.

<br>

*인수 객체*

> 객체를 생성해 인수를 줄이는 방법이 눈속임이라 여겨질지 모르지만 그렇지 않다. 
…
변수를 묶어 넘기려면 이름을 붙여야 하므로 결국은 **개념**을 표현하게 된다.
> 

<br>

*인수 목록*

> 때로는 인수 개수가 가변적인 함수도 필요하다.
> 

하지만 실상 가변 인수는 다항 함수가 아닌 경우가 많다(하지만 진짜 다항 함수인 경우 문제가 있다고 말한다.)

<br>

*동사와 키워드*

> 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다.
> 

> 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
> 

ex. findId(userId), containUser(username)

> 함수 이름에 **키워드**를 추가하는 형식이다.  즉, 함수 이름에 인수 이름을 넣는다.
…
그럼 인수 순서를 기억할 필요가 없어진다.
> 

ex. findById(id), findByIdAndName(id, name)

<br>

## 느낀점

대부분의 프로그래밍 언어에는 **함수**라는 개념이 있다. 하지만 이 함수를 왜! 사용하는지에 대해서는 깊이 생각해보지 않은 것 같다. 단순히 코드의 중복을 줄이기 위해서, 메모리 사용을 조금이라도 낮추기 위해 사용한다고 생각했었지만 지금이 챕터를 보면 함수를 쓰는건 그뿐만이 아니라는 것을 알 수 있다. 특히나 다음 독자(개발자)를 위해 함수를 사용한다는 느낌이 크다. 이렇게 생각의 관점이 바뀌니 현재 내가 사용하고 있는 함수에 대해 다시금 생각하게 되었다. 그저 메모리 낭비 때문만이 아닌, 이 코드를 처음보는 독자의 시점에서 내 함수는 어떻게 보일까, 과연 그 의미에 맞는 역할을 하고 있는 것일까 하는 많은 생각들이 들었다. 위에서 말한 내용이 모든 코드에 적용된다고 믿진 않는다. 하지만 조금이라도 코드를 짜본 사람이라면 위 내용에 대해 공감하고, 다시금 생각하는 바가 있을 것이라 확신한다. (이 챕터를 읽은 후 다시 자신의 코드를 본다면 리펙토링하고 싶은 생각이 마구마구 들수도 있다!) **함수** 하나 잘 작성함으로 얻을 수 있는 유익이 많구나 라는 것을 인지하게 되었고,  가장 인상 깊었던 문구가 하나 있다.

> 어떤 코드든 절대로 무시하면 안되니까. 무시한 코드에 오류가 숨어드니까.
> 

이항 함수에 대해 설명하며, 나오는 문장인데 안일하게 생각하고 무시한 코드에 오류가 숨어든다는 말이 새삼 크게 다가와 꼭 작성하고 싶었다.
