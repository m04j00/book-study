# 12장 창발성

<br>
 
### 창발성 설계로 깔끔한 코드를 구현하자

> 우리들 대다수는 켄트 벡이 제시한 단순한 설계 규칙 네 가지가 소프트웨어 설계 품질을 크게 높여준다고 믿는다.
> 

> 켄트 벡은 다음 규칙을 따르면 설계는 ‘단순하다’고 말한다.
> 
1. 모든 테스트를 실행한다.
2. 중복을 없앤다.
3. 프로그래머 의도를 표현한다.
4. 클래스와 메서드 수를 최소로 줄인다. 

<br>
 
### 단순한 설계 규칙 1 : 모든 테스트를 실행하라

> 테스트를 철저히 거쳐 모든 테스트 케이스를 항상 통과하는 시스템은 ‘테스트가 가능한 시스템’이다. 당연하지만 중요한 말이다.
> 

> 테스트 케이스가 많을 수록 개발자는 테스트가 쉽게 코드를 작성한다. 따라서 철저한 테스트가 가능한 시스템을 만들면 더 나은 설계가 얻어진다.
> 

> 결합도가 높으면 테스트 케이스를 작성하기 어렵다.
> 

> 놀랍게도 ‘테스트 케이스를 만들고 계속 돌려라’라는 간단하고 단순한 규칙을 따르면 시스템은 낮을 결합도와 높은 응집력이라는, 객체 지향 방법론이 지향하는 목표를 저절로 달성한다.
> 

> 테스트 케이스를 작성하면 설계 품질이 높아진다.
> 

<br>
 
### 단순한 설계 규칙 2~4 : 리팩터링

> 코드를 정리하면서 시스템이 깨질까 걱정할 필요가 없다. 테스트 케이스가 있으니까!
> 

> 리팩터리 단계에서는 소트프웨어 설계 품질을 높이는 기법이라면 무엇이든 적용해도 괜찮다.
> 

<br>
 
### 중복을 없애라

> 우수한 설계에서 중복은 커다란 적이다. 
중복은 추가 작업, 추가 위험, 불필요한 복잡도를 뜻하기 때문이다.
> 

> 깔끔한 시스템을 만들려면 단 몇줄이라도 중복을 제거하겠다는 의지가 필요하다.
> 

> ‘소규모 재사용’은 시스템 복잡도를 극적으로 줄여준다. 소규모 재사용을 제대로 익혀야 대규모 재사용이 가능하다.
> 

> TEMPLATE METHOD패턴은 고차원 중복을 제거할 목적으로 자주 사용하는 기법이다.
> 

<br>
 
**TEMPLATE METHOD 패턴**

> *Defines the skeleton of an algorithm in a method, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithms structure. 
-* GoF Design Patterns
> 

알고리즘의 구조를 메서드에 정의하고, 하위 클래스에서 알고리즘 구조의 변경 없이 알고리즘을 재정의 하는 패턴

즉, 특정 작업을 처리하는 일부분을 서브 클래스로 캡슐화하여 전체적인 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내용을 바꾸는 패턴이다.

<br>
 
### 표현하라

> 자신이 이해하는 코드를 짜기는 쉽다. 코드를 짜는 동안에는 문제에 푹 빠져 코드를 구석구석 이해하니까. 하지만 나중에 코드를 유지보수할 사람이 코드를 짜는 사람만큼이나 문제를 깊이 이해할 가능성은 희박하다.
> 

> 그러므로 코드는 개발자의 의도를 분명히 표현해야 한다. 
개발자가 코드를 명백하게 짤 수록 다른 사람이 그 코드를 이해하기 쉬워진다. 
그래야 결함이 줄어들고 유지보수 비용이 적게 든다.
> 
1. 좋은 이름을 선택한다.
2. 함수와 클래스 크기를 가능한 줄인다. 
3. 표준 명칭을 사용한다.
4. 단위 테스트 케이스를 꼼꼼히 작성한다.

> 표현력을 높이는 가장 중요한 방법은 **노력**이다. 
…
나중에 읽을 사람을 고려해 조금이라도 쉽게 만들려는 충분한 고민은 거의 찾기 힘들다.
하지만 나중에 코드를 읽을 사람은 바로 자신일 가능성이 높다는 사실을 명심하자
> 

<br>
 
### 클래스와 메서드 수를 최소로 줄여라

> 가능한 독단적인 견해는 멀리하고 실용적인 방식을 택한다.
> 

> 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는데 있다.
> 

> 하지만 이 규칙은 간단한 설계 규칙 네 개 중 우선순위가 가장 낮다.
> 

<br>
 
### 결론

> 단순한 설계 규칙을 따른다면 (오랜 경험 후에야 익힐) 우수한 기법과 원칙을 단번에 활용할 수 있다.
> 

<br>
 
## 느낀점

 이번 주제의 결론에서는 말한다. 경험을 대신할 단순한 개발 기법은 없다고 이와 함께 추가적으로 말하는 것이 이책에서 소개하는 기법은 저자들이 수십년 동안 쌓은 경험의 정수며 이번 주제에서 말한 것(단순한 설계 규칙)을 따른다면 그 긴세월동안 저자들이 경험을 통해 익혔던 기법과 원칙을 압축적으로 한번에 익힐 수 있다고 한다. 이점에 유의하며 책을 읽으니 조금 더 꼼꼼히 읽게 되는 원동력이 되는 것 같아 이번 느낀점에 꼭 적고 싶었다. 

 다시 이번 주제로 넘어와서 이번에는 단순한 설계 규칙에 대해 설명하는 글이었다. 정말 보기에는 단순했다. 말 그대로 테스트의 중요성과 테스트 이후의 리팩터링 과정을 통해 코드를 깔끔하게 만들어가는 과정을 설명해주었기 때문이다. 여기서 가장 주목해야할 점은 모든 클린코드의 기본은 테스트코드라는 점이다. 이 책에서 말한 바를 빌려 말하자면 테스트 코드는 소위 예제로 보여주는 문서이다. 그렇기에 이후 해당 코드를 볼 독자 혹은 나를 위해서라도 각 메서드별, condition별 테스트 코드는 필수적이다. 이를 통해 독자가 이 클래스가 하는 역할을 한눈에 알아볼 수 있기 때문이다. 나머지 리팩터링 과정은 테스트케이스 작성 그 이후의 일이다. 테스트 케이스가 작성되지 않고 하는 리팩터링은 오히려 더 큰 위험을 불러올 수 있다. 다양한 테스트 케이스에 의해 테스트를 통과하는것은 변경된 사항이 문제가 없다는 객관적인 자료로써 사용될 수 있을 것이다. 

 우리는 더할나위 없이 감사한 세상에 살고있는지도 모르겠다. 앞서 말했듯 과거의(혹은 지금도) 뛰어난 개발자들이 많은 시간을 들여 연구하고, 개발한 다양한 자료들을 이렇게 하나의 책으로 혹은 블로그나 강의로 그들이 들인 시간의 절반도 채 되지 않는 시간동안 많은 것을 습득할 수 있다. 하지만 모두가 알듯이 이를 습득하는 것과 활용하는 것은 다르다. 짧은 시간안에 습득은 했지만, 활용을 하지 않는다면 이는 앞선 선배들이 많은 시간을 들여 연구한 것이 무용지물이 되기 때문이다. 물론 어렵다. 하지만 이 책에서 말하듯 **노력**이 가장 큰 깔끔한 코드를 만드는 방법인 것 같다. 나도 아직 많이 부족함을 이 책을 읽으며 많이 느끼지만, 노력을 통해 조금이나마 저자들의 경험의 정수를 활용을 할 수 있는 개발자가 되고 싶다.
